# 飞书 Claude 机器人 - 交互设计文档

## 设计理念

**核心思想**：简洁直观，减少学习成本，符合用户直觉。

### 1. 命令设计原则

#### 原则 1：@机器人 = 命令模式

**设计决策**：所有 `@机器人` 的消息都被识别为命令，不会透传给 Claude CLI。

**原因**：
- 用户在群里 `@机器人` 通常是有明确意图的（管理、查询、配置）
- 避免误操作：用户 `@机器人` 问问题，结果被当成普通对话处理
- 清晰的模式区分：`@机器人` = 命令，不 `@` = 对话

**实现**：
```go
if isMentioned {
    // 解析并执行命令
    // bind, ls, help
} else {
    // 正常对话，转给 Claude CLI
}
```

#### 原则 2：去斜杠化，自然语言交互

**设计决策**：命令不需要 `/` 前缀，直接使用自然语言关键词。

**对比**：
```
❌ 传统方式：/bind 1
✅ 我们的设计：@机器人 bind 1
```

**原因**：
- 飞书用户习惯：在聊天工具中，`@某人` 后直接说需求更自然
- 减少记忆负担：不需要记住 `/` 前缀
- 统一模式：所有命令都以 `@机器人` 开头，格式一致

**命令格式**：
```
@机器人 bind <序号或路径>   # 绑定项目
@机器人 ls                  # 查看列表
@机器人 help                # 显示帮助
@机器人                      # 空消息 = 帮助
```

#### 原则 3：双路径输入，灵活便捷

**设计决策**：`/bind` 命令支持两种输入方式：
- **序号**：`@机器人 bind 1`
- **路径**：`@机器人 bind ~/Desktop/code/project-a`

**原因**：
- **序号方式**：快速选择，适合频繁操作的项目
  - 场景：常用的 3-5 个项目，直接输入数字比打路径快
  - 优势：路径通常很长，序号只需 1 位数字

- **路径方式**：灵活扩展，支持任意路径
  - 场景：新项目、临时目录、不在 `~/Desktop/code` 下的项目
  - 优势：不受限，完整控制

**实现细节**：
```go
// 检测参数类型
if param[0] >= '0' && param[0] <= '9' {
    // 序号模式：从列表中获取
    projectPath = projects[index-1]
} else {
    // 路径模式：直接使用
    projectPath = param
}
```

### 2. 信息展示设计

#### 列表展示：序号 + 完整路径

**输出格式**：
```
📂 可用项目列表：

1. /Users/wen/Desktop/code/18feishu
2. /Users/wen/Desktop/code/project-b
3. /Users/wen/Desktop/code/test-app

共 3 个项目

使用方法：@机器人 bind <序号>
```

**设计要点**：
1. **序号从 1 开始**：符合人类习惯（不是 0）
2. **完整路径显示**：用户能清楚知道绑定的目录
3. **数量统计**：告知总数，辅助判断序号范围
4. **操作提示**：底部显示使用方法，降低学习成本

#### 帮助信息：上下文相关

**当前绑定状态**：
```
📂 当前项目路径：

/Users/wen/Desktop/code/18feishu

🤖 飞书 Claude 机器人使用指南
...
```

**未绑定时**：
```
📂 当前项目路径：未绑定（使用默认目录）

🤖 飞书 Claude 机器人使用指南
...
```

**设计要点**：
- **状态前置**：用户最关心的是"当前绑定了哪个项目"
- **动态显示**：帮助文档顶部显示当前状态，信息一目了然
- **友好提示**：未绑定时说明会使用默认目录，消除困惑

### 3. 错误处理设计

#### 清晰的错误提示

**序号超出范围**：
```
❌ 序号超出范围

有效范围：1-3
```

**路径不存在**：
```
❌ 绑定失败: 路径不存在或不是目录
```

**用法错误**：
```
❌ 用法错误

@机器人 bind <序号或路径>

示例：
@机器人 bind 1
@机器人 bind ~/Desktop/code/my-app
```

**设计原则**：
1. **错误原因明确**：用户知道哪里错了
2. **解决方法清晰**：告诉用户正确的格式
3. **提供示例**：直观展示正确用法

### 4. 对话模式分离

#### 两种场景

| 场景 | 触发方式 | 行为 | 示例 |
|------|----------|------|------|
| **命令模式** | `@机器人` | 执行命令，返回结果 | `@机器人 ls` → 显示项目列表 |
| **对话模式** | 不 `@` | 透传给 Claude CLI | `帮我看看这个项目` → Claude 在绑定目录下运行 |

#### 群聊 vs 私聊

**群聊**：
- 支持项目绑定
- 未绑定时使用默认目录
- 可以 `@机器人` 执行命令

**私聊**：
- 不支持项目绑定（只有一个人）
- 固定使用默认目录
- 不需要 `@机器人`（直接对话）

**原因**：
- 群聊通常是多人协作场景，需要项目管理
- 私聊是个人助手，不需要复杂配置
- 简化私聊体验，直接对话更流畅

### 5. 配置文件设计

#### 存储位置
```
~/.feishu-bot/projects.json
```

#### 文件格式
```json
{
  "oc_61cb6d77fa53eeee339c2195868e64d1": "/Users/wen/Desktop/code/18feishu",
  "oc_aaaabbbbcccc": "/Users/wen/Desktop/code/project-b"
}
```

**设计要点**：
1. **简单映射**：`chat_id` → `project_path`，没有多余字段
2. **持久化**：重启后绑定关系保留
3. **用户目录**：放在 `~/.feishu-bot/`，用户可访问和备份

#### 绑定覆盖
- **再次绑定同一个群**：直接覆盖旧路径
- **用途**：切换项目时，重新 `bind` 即可
- **无需 unbind 命令**：简化操作，直接覆盖

### 6. 技术实现细节

#### @检测机制
```go
func (mh *MessageHandler) isMentioned(message *larkim.EventMessage) bool {
    return len(message.Mentions) > 0
}
```

**飞书事件结构**：
- 消息中包含 `Mentions` 数组
- `@机器人` 时 `Mentions` 非空
- `@其他人` 时 `Mentions` 也非空（但不会匹配机器人 ID）

**简化实现**：
- 当前：只要有 `Mentions` 就认为 `@机器人`
- 优化：可以检查 `Mentions[0].Id` 是否等于机器人 ID

#### 命令解析
```go
// 1. 移除 @提及部分
parts := strings.Fields(trimmedContent)
if len(parts) > 0 && strings.HasPrefix(parts[0], "@") {
    trimmedContent = strings.Join(parts[1:], " ")
}

// 2. 提取命令词
cmdParts := strings.Fields(trimmedContent)
cmd := cmdParts[0]  // "bind", "ls", "help"

// 3. 路由到对应处理器
if cmd == "bind" {
    return mh.handleBindCommand(...)
}
```

**鲁棒性**：
- 处理多个空格：`@机器人   bind   1`
- 处理换行：用 `strings.Fields` 自动忽略
- 处理大小写：命令词小写匹配

### 7. 用户体验优化

#### 1. 智能默认值
- **未绑定群聊**：使用默认目录（机器人运行目录）
- **空 `@`**：显示帮助（不需要输入 `help`）

#### 2. 快捷操作
- **序号绑定**：常用项目直接输入数字
- **路径展开**：`~` 自动展开为用户主目录
- **相对路径**：支持相对路径，自动转换为绝对路径

#### 3. 即时反馈
- **绑定成功**：立即显示绑定路径
- **错误提示**：清晰的错误信息和解决方法
- **状态可见**：`/help` 顶部显示当前绑定状态

### 8. 设计演进历史

#### v1.0：CardKit 方式（已废弃）
```
@机器人 问题
→ 创建卡片 → 流式更新 → 200+ API 调用
```
**问题**：
- API 消耗大
- 实现复杂
- 限流风险

#### v2.0：文本消息方式（当前）
```
@机器人 bind 1  → 直接回复文本
问题           → 流式分段发送文本
```
**优势**：
- API 调用少（2-5 次/对话）
- 实现简单
- 无限流风险

### 9. 未来扩展方向

#### 可能的改进

1. **命令别名**：
   ```
   @机器人 绑定 1       # 支持中文
   @机器人 b 1          # 支持缩写
   ```

2. **批量操作**：
   ```
   @机器人 bind-all     # 绑定所有群聊到同一个项目
   ```

3. **项目管理**：
   ```
   @机器人 unbind       # 解绑
   @机器人 rename 1 新名字  # 重命名项目
   ```

4. **智能推荐**：
   ```
   @机器人              # 显示最近使用的项目
   @机器人 suggest      # 根据对话内容推荐项目
   ```

### 10. 总结

**核心设计哲学**：
> 让复杂的技术隐藏在简单的交互背后。

**用户视角**：
- 我要绑定项目 → `@机器人 bind 1`
- 我要看列表 → `@机器人 ls`
- 我要问问题 → 直接发消息

**开发者视角**：
- 清晰的模式分离
- 简单的命令解析
- 友好的错误处理

这种设计平衡了**易用性**和**功能性**，符合飞书用户的使用习惯，同时保持了系统的可扩展性。
